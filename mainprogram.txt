
// consider having left and right joystick motion drag forward or back joystick motion
//Zen Flute Low RF version (FCC approved)
// compile with teensy 4.0/usb serial, midi, audio 600MHz
// Version 4.5 11/2021
//notes: Faust Flute Model
//set for SWAM sax software
/*
   1/21/2023
   faster calculation update (shortened autocorrelation to 200
   shortened loop timer delay (why even have)
   larger hysteresis
   new phase calculation curve (third order, new numbers)
   check correlation before updating frequency
   turn off control midi signals when idle
   to do--analog filtering and phase shifting
    can't increase analog resolution and still hit 20us on interrupt
    hardware VCA for controlling speaker and microphone?
*/

// //***************************MIT Software License*******************************
//Copyright (c) 2022, 2023 Keith Baxter (info@museelectronicinstruments.com)
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, tuincluding without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.

//************************** End of MIT License*******************************

//This license is not a hardware license nor an implied license to hardware.
//Please support Muse Electronic Instruments (MEI) in its mission to offer
//innovative electronic instruments by purchasing the Zen Flute and other MEI products.  Thanks.




//***************************************
// libraries and global variables
//***************************************

int chordstate = 0;
int lastchordstate = 0;


#if !defined(ARDUINO_TEENSY40)
#error "Please Select Teensy 4.0 Board Type"
#endif

#if !defined(SERIAL)
#error "USB MIDI not enabled. Please set USB type to 'Serial'."
#endif

#include <Audio.h>
#include "flute.h"
#include <MIDI.h>
MIDI_CREATE_INSTANCE(HardwareSerial, Serial1, MIDI);

flute flute1;  //instantiate flute (code generated by: https://faustide.grame.fr/)
flute flute2;

//light ring
float tempred;
float tempblue;

unsigned long lighttime = 0;
int ledcounter = 0;
int colorcounter = 0;
unsigned int nowcolor;
#include <WS2812Serial.h>
const int numled = 16;
const int pin = 29;                      //will be 20 //Teensy 4.0:  1, 8, 14, 17, 20, 24, 29, 39



// The following are synthesizer blocks setup with a graphical
// tool described at pjrc.com/teensy/td_libs_Audio.html
// copying the following into the tool will generate a graphical
// layout of this synth.

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>


// GUItool: begin automatically generated code
AudioSynthWaveformDc dc1;          //xy=72,270
AudioSynthWaveformDc dc2;          //xy=74,306
AudioMixer4 mixer1;                //xy=217,235.00000190734863
AudioFilterStateVariable filter1;  //xy=330,241.00000190734863
AudioEffectFreeverb freeverb1;     //xy=429.00000381469727,171.00000095367432
AudioEffectFreeverb freeverb2;     //xy=434,384.00000190734863
AudioMixer4 mixer3;                //xy=548,320.00000381469727
AudioMixer4 mixer2;                //xy=549.0000038146973,236.00000190734863
AudioAmplifier amp2;               //xy=736.0000038146973,391.00000381469727
AudioAmplifier amp1;               //xy=739.0000038146973,353.00000286102295
AudioOutputUSB usb1;               //xy=866.0000076293945,233.00000190734863
AudioOutputMQS mqs1;               //xy=875.0000057220459,374.00000286102295
AudioConnection patchCord1(dc1, 0, mixer1, 2);
AudioConnection patchCord2(dc2, 0, mixer1, 3);
AudioConnection patchCord3(mixer1, 0, filter1, 0);
AudioConnection patchCord4(filter1, 0, freeverb1, 0);
AudioConnection patchCord5(filter1, 0, mixer2, 1);
AudioConnection patchCord6(filter1, 0, freeverb2, 0);
AudioConnection patchCord7(filter1, 0, mixer3, 1);
AudioConnection patchCord8(freeverb1, 0, mixer2, 0);
AudioConnection patchCord9(freeverb2, 0, mixer3, 0);
AudioConnection patchCord10(mixer3, 0, usb1, 1);
AudioConnection patchCord11(mixer3, amp2);
AudioConnection patchCord12(mixer2, 0, usb1, 0);
AudioConnection patchCord13(mixer2, amp1);
AudioConnection patchCord14(amp2, 0, mqs1, 1);
AudioConnection patchCord15(amp1, 0, mqs1, 0);
// GUItool: end automatically generated code

// hand generated code to connect to Faust model
AudioConnection patchCord17(flute2, 0, mixer1, 1);
AudioConnection patchCord16(flute1, 0, mixer1, 0);

//pin assignments Teensy 4.0

const int LEDpin = 13;           //on board led
const int micInputPin = A0;      //mouth microphone
const int mouthSpkrOutput = 15;  //mouth speaker output
const int keyButton = 0;         //cherry switch button
const int bluePin = 5;           //led pins
const int greenPin = 6;
const int redPin = 8;
const int modePin = A3;       //mode button on joystick
const int monitorPin1 = 4;    //right monitor channel
const int monitorPin2 = 3;    //left monitor channel
const int joystickPin1 = A5;  //joystick front/back
const int joystickPin2 = A4;  //joystick left/right

unsigned long joyprocessingtime = 0;

//********************************************************************
// Acoustic Volume Processor Settings
//********************************************************************

float ultimatephase = 0;
float polyultimatephase = 0;
float phasebump[26][2] =  // black PCB flute
  { { 2000, 0 },
    { 1244.51, 0 },
    { 1174.66, 0 },
    { 1108.73, 0 },
    { 1046.5, 0 },
    { 987.77, 1 },
    { 932.33, 2 },
    { 880, 3 },
    { 830.61, 4 },
    { 783.99, 7 },
    { 739.99, 9 },
    { 698.46, 12 },
    { 659.25, 18 },
    { 622.25, 22 },
    { 587.33, 29 },
    { 554.37, 38 },
    { 523.25, 46 },
    { 493.88, 55 },
    { 466.16, 62 },
    { 440, 72 },
    { 415.3, 85 },
    { 392, 95 },
    { 369.99, 88 },
    { 349.23, 90 },
    { 329.63, 90 },
    {
      311.13,
      90,
    } };


float ultimatespeakergain = .1;
float rampup = 0;
float polyultimatepspeakergain = .1;
float gainoffset = 0;
float speakerbump[26][2] =  //speaker gain adjustments (freq, gain)
  {
    { 2000.51, 1 },  //!!!!
    { 1244.51, 1 },
    { 1174.66, 1 },
    { 1108.73, 1 },
    { 1046.50, 1 },
    { 987.77, 1 },
    { 932.33, 1 },
    { 880.00, 1 },
    { 830.61, 1 },
    { 783.99, 1 },
    { 739.99, 1 },
    { 698.46, 1 },
    { 659.15, 1 },
    { 622.15, 1 },
    { 587.33, 1 },
    { 554.37, 1 },
    { 523.1, 1 },
    { 493.88, 1.2 },
    { 466.16, 2 },
    { 440.00, 3 },
    { 415.10, 4 },
    { 392.00, 4 },
    { 369.99, 5 },
    { 349.23, 3 },
    { 329.63, 1.4 },
    { 311.13, 1.4 },
  };

float ultimatefilter = 1;
float polyultimatefilter = 1;
float filterbump[26][2] = {
  { 1318.51, 1 },
  { 1244.51, 1 },
  { 1174.66, 1 },
  { 1108.73, 1 },
  { 1046.50, 1 },
  { 987.77, 1 },
  { 932.33, 1 },
  { 880.00, 1 },
  { 830.61, 1 },
  { 783.99, 1 },
  { 739.99, 1 },
  { 698.46, 1 },
  { 659.25, 2 },
  { 622.25, 3 },
  { 587.33, 4 },
  { 554.37, 5 },
  { 523.25, 6 },
  { 493.88, 6 },
  { 466.16, 6 },
  { 440.00, 6 },
  { 415.30, 6 },
  { 392.00, 6 },
  { 369.99, 6 },
  { 349.23, 6 },
  { 329.63, 6 },
  { 311.13, 6 },
};


// tube length of Faust flute model to frequency
//calculated using https://arachnoid.com/polysolve/
int tubevalue1 = 0;
int tubevalue2 = 0;

const float tubelength[59] = {
  98.00,
  103.83,
  110.00,
  116.54,
  123.47,
  130.81,
  138.59,
  146.83,
  155.56,
  164.81,
  174.61,
  185.00,
  196.00,
  207.65,
  1.69,
  1.68,
  1.60,
  1.52,
  1.4,
  1.31,
  1.23,
  1.14,
  1.047,
  .9690,
  .8950,
  .8236,
  .7570,
  .6970,
  .6364,
  .5810,
  .5330,
  .4775,
  .4305,
  .3866,
  .3445,
  .3065,
  .2695,
  .2355,
  .2001,
  .1691,
  .1395,
  .1125,
  .0865,
  .0610,
  .0180,
  .0170,
  -.005,
  1479.98,
  1567.98,
  1661.22,
  1760.00,
  1864.66,
  1975.53,
  2093.00,
  2217.46,
  2349.32,
  2489.02,
  2637.02,
  2793.83,
};


//const float pressure[59] = {98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61,
//                            185.00, 196.00, .1, .1, .1, .1, .1, .1, .1, .10, .11, .12, .12, .13, .14, .16, .16, .17, .17, .17, .18, .19, .19,
//                            .20, .21, .24, .28, .32, .36, .38, .40, .43, .46, .48, .51, .60, .67,
//                            .7, .71, 1760.00, 1864.66, 1975.53, 2093.00,
//                            2217.46, 2349.32, 2489.02, 2637.02, 2793.83,
//                           };


//list of chromatic note frequencies A=440
const float chromatic[60] = {
  98.00,
  103.83,
  110.00,
  116.54,
  123.47,
  130.81,
  138.59,
  146.83,
  155.56,
  164.81,
  174.61,
  185.00,
  196.00,
  207.65,
  220.00,
  233.08,
  246.94,
  261.63,
  277.18,
  293.66,
  311.13,
  329.63,
  349.23,
  369.99,
  392.00,
  415.30,
  440.00,
  466.16,
  493.88,
  523.25,
  554.37,
  587.33,
  622.25,
  659.25,
  698.46,
  739.99,
  783.99,
  830.61,
  880.00,
  932.33,
  987.77,
  1046.50,
  1108.73,
  1174.66,
  1244.51,
  1318.51,
  1396.91,
  1479.98,
  1567.98,
  1661.22,
  1760.00,
  1864.66,
  1975.53,
  2093.00,
  2217.46,
  2349.32,
  2489.02,
  2637.02,
  2793.83,
  2637.02,
};


String noteNames[] = { "G", "G#", "A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#" };
byte octave = 0;
byte noteInOctave = 0;
int noteNumber = 0;

//matching midi values
const int midiconvert[60] = { 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
                              53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
                              63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
                              73, 74, 75, 76, 77, 78, 79, 80, 81, 82,
                              83, 84, 85, 86, 87, 88, 89, 90, 91, 92,
                              93, 94, 95, 96, 97, 98, 99, 100, 101, 102 };


//selected scales

const float SCALESIZE = 30;  //number of notes that can be identified


int scalefilter[31] = { 2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21, 22, 24, 26,
                        28, 29, 31, 33, 34, 36, 38, 40, 41, 43, 45, 46, 48, 50, 52, 54 };  //Cmaj-default


const int scalefilter1[31] = { 2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21, 22, 24, 26,
                               28, 29, 31, 33, 34, 36, 38, 40, 41, 43, 45, 46, 48, 50, 52, 54 };  //C maj/Eb maj heptonic



const int scalefilter2[31] = { 1, 4, 5, 6, 9, 10, 11, 13, 16, 17, 18, 21, 22, 23, 25, 28, 29, 30, 33, 34,
                               35, 37, 40, 41, 42, 45, 46, 47, 49, 52, 53 };  //Cmaj Persian harmonic major

const int scalefilter3[31] = { 1, 5, 7, 8, 12, 13, 17, 19, 20, 24, 25, 29, 31, 32, 36, 37, 41, 43, 44, 48, 49,
                               53, 55, 56, 56, 56, 56, 56, 56, 56, 56 };  //C Japanese scale Hirajoshi


const int scalefilter4[31] = { 2, 4, 5, 7, 8, 10, 12, 14, 16, 17, 19, 20, 22, 24, 26, 28, 29, 31, 32, 34, 36, 38, 40, 41, 43,
                               44, 46, 48, 50, 52, 53 };  //C hawaiian


const int scalefilter5[31] = { 2, 3, 5, 7, 9, 10, 12, 14, 15, 17, 19, 21, 22, 24, 26,
                               27, 29, 31, 33, 34, 36, 38, 39, 41, 43, 45, 46, 48, 50, 51, 53 };  //Dminor

const int scalefilter6[31] = { 2, 3, 5, 7, 9, 10, 12, 14, 15, 17, 19, 21, 22, 24, 26,
                               27, 29, 31, 33, 34, 36, 38, 39, 41, 43, 45, 46, 48, 50, 51, 53 };  //Fmaj

const int scalefilter7[31] = {
  2,
  3,
  7,
  8,
  12,
  14,
  15,
  19,
  20,
  24,
  26,
  27,
  31,
  32,
  36,
  38,
  39,
  43,
  44,
  48,
  50,
  51,
  51,
  51,
  51,
  51,
  51,
  51,
  51,
  51,
  51,
};  //Miyako-bushi

//*******Sampling ISR variables and objects*******
// Create an IntervalTimer object to call buffer ISR
IntervalTimer samplingTimer;
const int BUFFSIZE = 610;                         //sample at 20 us equals 81 HZ limit
static volatile int h;                            //bufferindex
static volatile int filteredmicbuffer[BUFFSIZE];  //used for frequency extraction
static volatile int micval, driveval, monitorval;

//direct drive variables
static volatile float rawmicbuffer[BUFFSIZE];
float snapshotbuffer[BUFFSIZE];


//frequency extraction variables
unsigned long freqcalc = 0;
float nowfreq = 0;


//closest-note  variables/hysteresis
float closestfrequency = 0;
int closestscalenumber = 0;
float driveerror = 9999;
int hyster_closest_scale_number = 0;
float hysterclosestnote = 0;
int hyster_last_closest_scale_number = 0;
bool newnote = 0;
int hysterpreviousplayednotenumber1 = 0;
int hysteresisamount = 4;  //smaller is more hysteresis  1/5 here


//********************************************************************
// UI variables
//********************************************************************

bool cherry1 = false;
bool button1toggle = true;

unsigned long bouncetimerA1 = 0;
unsigned long bouncetimerB1 = 0;

bool modebutton = false;
unsigned long modebouncetimer = 0;
unsigned long offtimer = 0;
int modecount = 0;
bool modeupdate = false;
int lastmodecount = 1;
unsigned long uncolor = 0;

float redpart = 0;
float bluepart = 0;
float colorsaturation = 0;
float integratedsat = 0;

unsigned long joytime = 0;

//********************************************************************
// Debugging/tuning variables
//********************************************************************

unsigned long last_time = millis();
unsigned long profiledelta = 0;
unsigned long profiletimer = 0;


//********************************************************************
// Misc variables
//********************************************************************

//sleep timer when not played in a while
unsigned long sleeptimer = 0;
unsigned long alivetimer = 0;
bool woken = false;
bool wokenstall = false;
unsigned long wokentime = 0;
bool lastwoken = true;
bool lightstall = true;

float rawjoystickvalue1;
float lastrawjoystickvalue1;
float rawjoystickvalue2;
int whamcorrection1 = 5;
int whamcorrection2 = 1;
bool toggle = false;
float expressionpedal1;
float expressionpedal2;
float expressionpedal3;
float flutepedal_0;
float flutepedal_1;
float flutepedal_2;
float flutepedal_3;
float lastexpression1 = 0;
float lastexpression2 = 0;
float lastexpression3 = 0;


float room_size = 0;
float reverb_amount;
float reverb_size;
float reverb_damping;

//SWAM sax synth MIDI interface values
int lastMIDI = 0;

int MIDIvolume = 127;

//filter interpolation
float filtercoeff = .1;
float flowfreq = 0;
float fhighfreq = 1440;
int fhighindex = 0;
float highfilter = 1;
float lowfilter = 1;

//********************************************************************
// Monitor Output Variables
//********************************************************************
float monitorgain = .1;
static float sineincrement = 1;
static unsigned long ISRlasttime = 0;
//https://www.wolframalpha.com/input/?i=table+round%28127*%28sin%282*pi*t%2F100%29%2B1%29%29+from+0+to+99
const int16_t sinetable[100] = { 127, 135, 143, 151, 159, 166, 174, 181, 188,
                                 195, 202, 208, 214, 220, 225, 230, 234, 238, 242, 245, 248, 250, 252, 253,
                                 254, 254, 254, 253, 252, 250, 248, 245, 242, 238, 234, 230, 225, 220, 214,
                                 208, 202, 195, 188, 181, 174, 166, 159, 151, 143, 135, 127, 119, 111, 103,
                                 95, 88, 80, 73, 66, 59, 52, 46, 40, 34, 29, 24, 20, 16, 12, 9, 6, 4, 2, 1,
                                 0, 0, 0, 1, 2, 4, 6, 9, 12, 16, 20, 24, 29, 34, 40, 46, 52, 59, 66, 73, 80,
                                 88, 95, 103, 111, 119 };

float quiescentstate = 0;
float squelch = 1;
float monitorsquelch = 1;

int note_mode = 0;  //sound off on note transitions
unsigned long repeat_time = 0;
int repeat_count = 0;

//autocorrelation frequency extraction
float auto_corr = 0;
float maxauto_corr = 0;
int samplecount = 0;
float micaverage = 0;
float lastmicaverage = 0;

const int Cnote = 60;
const int Gnote = 55;
const int Fnote = 53;
const int Anote = 57;
const int Bnote = 59;
const int Enote = 64;
const int Dnote = 62;


// ***************************************
//***************************************
// Setup
//***************************************
//***************************************
void setup()
{
  MIDI.begin();
  Serial.begin(38400);
  //Serial.print("Serial open");
  // audio bus between synth objects.  Set by looking at CPU usage
  AudioMemory(20);  //needed for teensy audio model


  analogWriteResolution(10);  //A/D too slow for 10 bits
  //clock speed from https://www.pjrc.com/teensy/td_pulse.html
  analogWriteFrequency(mouthSpkrOutput, 146484);  // Hz585937);
  analogWriteFrequency(monitorPin1, 585937);
  analogWriteFrequency(monitorPin2, 585937);
  analogReadResolution(8);

  samplingTimer.begin(grabdata, 20);  // ISR to grab mic data every 20 us
  samplingTimer.priority(200);        //0 is bad make this get interrupted by something, why?
  delay(1000);

  //***************I/O*****************



  pinMode(LEDpin, OUTPUT);           //led
  pinMode(micInputPin, INPUT);       //microphone A0
  pinMode(mouthSpkrOutput, OUTPUT);  //mouth sine output
  pinMode(keyButton, INPUT_PULLUP);
  pinMode(monitorPin1, OUTPUT);
  pinMode(monitorPin2, OUTPUT);
  pinMode(joystickPin1, INPUT);
  pinMode(joystickPin2, INPUT);
  pinMode(bluePin, OUTPUT);
  pinMode(greenPin, OUTPUT);
  pinMode(redPin, OUTPUT);
  pinMode(modePin, INPUT_PULLUP);


  analogWrite(bluePin, 1024);  //blank LED
  analogWrite(greenPin, 1024);
  analogWrite(redPin, 1024);

  mixer1.gain(0, .2);  //flute mixer (Root)
  mixer1.gain(1, .2);  // (5th)
  mixer1.gain(2, 0);
  mixer1.gain(3, 0);

  reverb_amount = .4;
  reverb_damping = 0.5;
  room_size = .9;
  mixer2.gain(0, reverb_amount);      //reverb amount
  mixer2.gain(1, 1 - reverb_amount);  //dry signal

  mixer3.gain(0, reverb_amount);      //reverb amount
  mixer3.gain(1, 1 - reverb_amount);  //dry signal

  filter1.frequency(1500);
  filter1.resonance(.7);

  freeverb1.roomsize(room_size);
  freeverb1.damping(reverb_damping);

  freeverb2.roomsize(room_size);
  freeverb2.damping(reverb_damping);

  amp1.gain(.25);
  amp2.gain(.25);

  flute1.setParamValue("breathGain", 0);
  flute1.setParamValue("breathCutoff", 2000);
  flute1.setParamValue("vibratoFreq", 7);

  flute2.setParamValue("breathGain", .2);
  flute2.setParamValue("breathCutoff", 2000);
  flute2.setParamValue("vibratoFreq", 7);

  leds.begin();  //light ring
}

//***************************************
//***************************************
// Main Loop
//***************************************
//***************************************

void loop()
{
  profiledelta = micros() - profiletimer;  //end profile
  profiletimer = micros();                 //start profile



  cli();                                                                               //alternate reads of A/D to handle read time delay
  if (toggle == true) rawjoystickvalue1 = analogRead(joystickPin1) - whamcorrection1;  //space these apart to keep interrupt length down
  if (toggle == false) rawjoystickvalue2 = analogRead(joystickPin2) - whamcorrection2;
  sei();
  toggle = !toggle;



  if (millis() > last_time)  //debugging printout
  {
    last_time = millis() + 500;

    //track pitch with color
    if (woken == true)
    {
      //single LED
      // redpart = int(mapfloat(nowfreq, 400, 1400, 1024, 0));
      // if (redpart < 0) redpart = 0;
      // if (redpart > 1024) redpart = 1024;
      // bluepart = 1024 - redpart;

      // integratedsat = (colorsaturation - integratedsat) / 10 + integratedsat;
      // //analogWrite(redPin, int(1023 - (redpart * colorsaturation)));  //blank LED
      // //analogWrite(bluePin, int(1023 - (bluepart * colorsaturation)));
      // //light ring
      // float tempred = mapfloat(nowfreq, 300, 1700, 256, 0) * integratedsat;
      // float tempblue = (256 - tempred) * integratedsat;

      // nowcolor = (int(tempred) << 16) + int(tempblue);
      // if (nowcolor < 10) nowcolor = 128;
    }
//debugging values
    //        Serial.print("profile: ");
    //        Serial.println(profiledelta);
    //    Serial.print("flutepedal_0: ");
    //    Serial.println(flutepedal_0);
    //    Serial.print("flutepedal_1: ");
    //    Serial.println(flutepedal_1);
    //    Serial.print("flutepedal_2: ");
    //    Serial.println(flutepedal_2);
    //    Serial.print("samplecount: ");
    //    Serial.println(samplecount);
    //    Serial.print(" ultimatefilter: ");
    //    Serial.println(ultimatefilter  );
    //    Serial.print(" polyultimatefilter: ");
    //    Serial.println(polyultimatefilter  );
    //    Serial.print(" ultimatespeakergain: ");
    //    Serial.println(ultimatespeakergain);
    //    Serial.print(" squelch: ");
    //    Serial.println(squelch);
    //    Serial.print(" polyultimatephase: ");
    //    Serial.println(polyultimatephase);
    //    Serial.print("nowfreq: ");
    //    Serial.println(nowfreq);
    //    Serial.print("redpart: ");
    //    Serial.println(redpart);
    //    Serial.print("notenumber: ");
    //    Serial.println(scalefilter[hyster_closest_scale_number]);

    //    noteNumber = scalefilter[hyster_closest_scale_number];
    //    octave = 1 + noteNumber / 12;
    //    noteInOctave = noteNumber % 12;
    // Serial.print("modecount");
    // Serial.println(modecount);
    //   Serial.print(noteNames[noteInOctave]);
    // Serial.println(octave + 1);

    //
    //    Serial.print("tubelength: ");
    //    Serial.println(tubelength[tubevalue1]);
    //    Serial.print("tubeindex: ");
    //    Serial.println(tubevalue1);
    //
    //
    //
    //    Serial.print("quiescentstate: ");
    //    Serial.println(quiescentstate);
    //    Serial.println("");
    //    Serial.print(" rawjoystickvalue1: ");
    //    Serial.println(rawjoystickvalue1);
    //    Serial.print(" rawjoystickvalue2: ");
    //    Serial.println(rawjoystickvalue2);
    //    Serial.print(" chordstate: ");
    //    Serial.println(chordstate);
    //    Serial.print("midiout: ");
    //    Serial.println(midiconvert[scalefilter[hyster_closest_scale_number]]);
    //      Serial.print(" ultimatefilter: ");
    //      Serial.println(ultimatefilter  );
    // Serial.print(" expressionpedal1: ");
    // Serial.println(expressionpedal1);
    //      Serial.print(" ultimatespeakergain: ");
    //      Serial.println(ultimatespeakergain);
    //      Serial.print(" ultimatephase: ");
    //      Serial.println(ultimatephase);
    //      Serial.print(" flowfreq: ");
    //      Serial.println(flowfreq);
    //      Serial.print(" fhighfreq: ");
    //      Serial.println(fhighfreq);
    //      Serial.print(" nowfreq: ");
    //      Serial.println(nowfreq);
    //      Serial.print(" highfilter: ");
    //      Serial.println(highfilter);
    //      Serial.print(" lowfilter: ");
    //      Serial.println(lowfilter);
    //      Serial.print("all=");
    //      Serial.print(AudioProcessorUsage());
    //      Serial.print(",");
    //      Serial.print(AudioProcessorUsageMax());
    //      Serial.print("    ");
    //      Serial.print("Memory: ");
    //      Serial.print(AudioMemoryUsage());
    //      Serial.print(",");
    //      Serial.println(AudioMemoryUsageMax());
  }



  /////////////////////////////////
  //periodic calculations: frequency extraction, phase and gain interpolation
  /////////////////////////////////
  if ((freqcalc + 4) < millis())  //periodic calculations  //mostly loop limited
  {


    freqcalc = millis();
    if ((woken == true) && (rampup < 1)) rampup = rampup + .01;  //reduces impulse pop when speaker first turned on
    if (rampup > 1) rampup = 1;

    //load and left justify copy of mic buffer for frequency analysis
    int temp11 = 0;
    int temph = h;
    for (int x = 0; x < BUFFSIZE; x++)
    {
      snapshotbuffer[x] = rawmicbuffer[temph + temp11];
      temp11--;
      if (temp11 + temph < 0) temp11 = BUFFSIZE - 1 - h;
    }

    //get data average and quiescent state
    quiescentstate = 0;
    micaverage = 0;
    for (int x = 0; x < BUFFSIZE; x++)
    {
      if (snapshotbuffer[x] > lastmicaverage) quiescentstate = snapshotbuffer[x] + quiescentstate;  //!!
      micaverage = snapshotbuffer[x] + micaverage;
    }
    quiescentstate = quiescentstate / BUFFSIZE;
    micaverage = micaverage / BUFFSIZE;  //!!
    lastmicaverage = micaverage;
    squelch = quiescentstate / 128;
    squelch = squelch / 2.5;
    monitorsquelch = squelch * .1;

    for (int x = 0; x < BUFFSIZE; x++)
    {
      snapshotbuffer[x] = snapshotbuffer[x] - micaverage;
    }


    AudioNoInterrupts();      //keep this short !!
    mixer1.gain(0, squelch);  //if lose mounth volume, supress output
    mixer1.gain(1, squelch);
    AudioInterrupts();

    if (wokenstall == false)
    {
      AudioInterrupts();  //!! needed
      mixer1.gain(0, 0);  //first keypress just wakes up mouthpiece, not output
      mixer1.gain(1, 0);
      AudioInterrupts();
      lightstall = true;
    }





    /////////////////////////////////
    //extract frequency
    //with true autocorrelation
    /////////////////////////////////
    auto_corr = 0;
    maxauto_corr = 0;
    samplecount = 0;
    float noshift = 0;
    int corr_state = 0;
    float lowlimit = 0;
    float highlimit = 0;
    for (int y = 0; y < 200; y++)
    {
      auto_corr = 0;
      for (int x = 0; x < 200; x++)  //BUFFSIZE - 300; x++)
      {
        auto_corr = auto_corr + (snapshotbuffer[x] * snapshotbuffer[x + y]);
      }
      if (y == 0)
      {
        noshift = auto_corr;  //the best match with no offset
        lowlimit = noshift * .3;
        highlimit = noshift * .6;
      }
      if ((corr_state == 0) && (auto_corr < lowlimit)) corr_state = 1;  //first dip
      if ((corr_state == 1) && (auto_corr > highlimit))                 //first rise
      {
        corr_state = 2;
        maxauto_corr = 0;
      }
      if ((corr_state == 2) && (auto_corr < lowlimit)) corr_state = 3;  //second dip

      if ((corr_state == 2) && (maxauto_corr < auto_corr))  //only track peak between first and second dip
      {
        maxauto_corr = auto_corr;
        samplecount = y;
      }
    }

    if (maxauto_corr > lowlimit) nowfreq = 100000 / (samplecount * 2);  //block update if lose correlation on fast note change





    /////////////////////////////////
    //end of extract frequency
    /////////////////////////////////


    //****************************************************************
    // filter interpolation
    //****************************************************************
    flowfreq = 0;
    fhighfreq = 1440;
    fhighindex = 0;
    //int flowindex = 0;
    highfilter = 1;
    lowfilter = 1;
    for (int r = 0; r < 26; r++)
    {
      if (filterbump[r][0] > nowfreq)
      {
        highfilter = filterbump[r][0];
        fhighindex = r;
        fhighfreq = filterbump[r][0];
      }
    }
    if (fhighindex < 25) flowfreq = filterbump[fhighindex + 1][0];
    else
      flowfreq = 1440;
    highfilter = filterbump[fhighindex][1];
    if (fhighindex < 25) lowfilter = filterbump[fhighindex + 1][1];
    else
      lowfilter = 1;
    if (fhighfreq - flowfreq != 0) ultimatefilter = highfilter + ((fhighfreq - nowfreq) / (fhighfreq - flowfreq)) * (lowfilter - highfilter);
    ////curve fits using https://arachnoid.com/polysolve/
    //        polyultimatefilter =    1.3028116967941878 + (nowfreq * -4.8515243730111479E1)
    //                                + (pow(nowfreq , 2) *  6.5267575937445646E4)
    //                                + (pow(nowfreq , 3) *  -3.7395710848884737E7) +
    //                                + (pow(nowfreq , 4) *  7.6311379912360719E11);
    //
    //    if (polyultimatefilter < 1) polyultimatefilter = 1;

    polyultimatefilter = 1.4544707373489768E1 + (nowfreq * 5.0868694535869553E-3) + (pow(nowfreq, 2) * -1.1649215512198190E-5);
    if (polyultimatefilter < 1) polyultimatefilter = 1;
    //****************************************************************
    // phase offset interpolation
    //****************************************************************

    float highfreq = 2000;
    int highindex = 0;
    //int  lowindex = 0;
    float highphase = 0;

    for (int r = 0; r < 26; r++)
    {
      if (phasebump[r][0] > nowfreq)
      {
        highfreq = phasebump[r][0];
        highindex = r;
        //highphase=phasebump[r][1];
      }
    }
    float lowfreq = 2000;
    float lowphase = 60;

    if (highindex < 26)
    {
      lowfreq = phasebump[highindex + 1][0];
      lowphase = phasebump[highindex + 1][1];
    }
    highphase = phasebump[highindex][1];
    ultimatephase = highphase + ((highfreq - nowfreq) / (highfreq - lowfreq)) * (lowphase - highphase);
    if (highindex > 25) ultimatephase = 100;


    polyultimatephase = ultimatephase;

    //https://arachnoid.com/polysolve/
    //     polyultimatephase =  3.513E2
    //    + (nowfreq * -1.075)
    //    + (pow(nowfreq , 2) * 1.2072E-3)
    //    + (pow(nowfreq , 3) * -5.876E-7)
    //    + (pow(nowfreq , 4) * 1.044E-10);




    if (polyultimatephase < 0) polyultimatephase = 0;
    //****************************************************************
    // speakergain interpolation
    //****************************************************************
    lowfreq = 0;
    highindex = 0;
    // lowindex = 0;
    float highspeakergain = 0;
    float lowspeakergain = 0;
    for (int r = 0; r < 26; r++)
    {
      if (speakerbump[r][0] > nowfreq)
      {
        highfreq = speakerbump[r][0];
        highindex = r;
      }
    }
    if (highindex < 25) lowfreq = speakerbump[highindex + 1][0];
    else
      lowfreq = 2000;
    highspeakergain = speakerbump[highindex][1];
    if (highindex < 25) lowspeakergain = speakerbump[highindex + 1][1];
    else
      lowspeakergain = 0;
    ultimatespeakergain = highspeakergain - ((highfreq - nowfreq) / (highfreq - lowfreq)) * (highspeakergain - lowspeakergain);
  }



  ultimatespeakergain = .5;  //!!!!

  gainoffset = 128 * (ultimatespeakergain - 1);
  /////////////////////////////////
  //find closest scale  quantization
  /////////////////////////////////

  driveerror = 9999;
  closestfrequency = 0;
  for (int x = 0; x < SCALESIZE; x++)
  {
    if (abs(chromatic[scalefilter[x]] - nowfreq) < driveerror)
    {
      driveerror = abs(chromatic[scalefilter[x]] - nowfreq);
      closestfrequency = chromatic[scalefilter[x]];
      closestscalenumber = x;
    }
  }

  /////////////////////////////////
  //recalculate closest scale note for hysteresis
  /////////////////////////////////

  hyster_closest_scale_number = closestscalenumber;
  float A = chromatic[scalefilter[hyster_closest_scale_number]];
  float B = chromatic[scalefilter[hyster_last_closest_scale_number]];
  newnote = false;
  if (A > B)
  {
    if (nowfreq < ((A + B) / 2) + ((A - B) / hysteresisamount))  // 1/5 is the hysteramount
      hyster_closest_scale_number = hyster_last_closest_scale_number;
  }
  else if (B > A)
  {
    if (nowfreq > ((A + B) / 2) - ((B - A) / hysteresisamount))
      hyster_closest_scale_number = hyster_last_closest_scale_number;
  }
  else
    newnote = true;

  hyster_last_closest_scale_number = hyster_closest_scale_number;

  //calculate sine table offset for monitor ouput
  sineincrement = (5000 / chromatic[scalefilter[hyster_closest_scale_number]]);  //test for drivefreq change?



  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// BEGIN UI
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /////////////////////////////////////////
  //sleep timer
  /////////////////////////////////////////

  //test sleep timer--turns off mouth speaker after a few seconds
  if ((sleeptimer < millis()) && (woken == true))
  {
    woken = false;  //go to sleep
    rampup = 0;
    wokenstall = false;
  }

  if ((woken == false) && (alivetimer < millis()) && (offtimer < millis()))  //slow blink to show battery is on
  {
    Colorme(modecount);
    alivetimer = millis() + 1500;
    delay(100);  //short blink
    analogWrite(bluePin, 1024);  //blue
      analogWrite(greenPin, 1024);
      analogWrite(redPin, 1024);
  }

  //maintains sleep timer even if no transition of button if button is on
  if (cherry1 == true)
  {
    sleeptimer = millis() + 5000;
    if (woken == false) wokentime = millis();
    woken = true;
  }
  if ((woken == true) && (wokentime + 500 < millis())) wokenstall = true;  //delay output for 2 seconds after mouth speaker active


  /////////////////////////////////////////
  //synthesizer mode button detect/ binary encoding etc
  /////////////////////////////////////////

  if ((digitalRead(modePin) == 0) && (modebutton == false))
  {
    modebutton = true;
    modecount++;
    modeupdate = true;
    Serial.print("mode:");
    Serial.println(modecount);
    if (modecount > 9) modecount = 0;
    Colorme(modecount);
    modebouncetimer = millis() + 300;
    offtimer = millis() + 3000;
    woken = false;
    wokenstall = false;
    switch (modecount)  //select scale
    {
      case 0:
        for (int x = 0; x < 31; x++) scalefilter[x] = scalefilter1[x];
        break;
      case 1:
        for (int x = 0; x < 31; x++) scalefilter[x] = scalefilter1[x];
        break;
      case 2:
        for (int x = 0; x < 31; x++) scalefilter[x] = scalefilter2[x];
        break;
      case 3:
        for (int x = 0; x < 31; x++) scalefilter[x] = scalefilter4[x];
        break;
      case 4:
        for (int x = 0; x < 31; x++) scalefilter[x] = scalefilter5[x];
        break;
      case 5:
        for (int x = 0; x < 31; x++) scalefilter[x] = scalefilter6[x];
        break;
      case 6:
        for (int x = 0; x < 31; x++) scalefilter[x] = scalefilter7[x];
        break;
    }
  }
  else if (millis() > modebouncetimer)
    if (digitalRead(modePin) == 1) modebutton = false;

  /////////////////////////////////
  // SENSING CHERRY SWITCH
  /////////////////////////////////

  if ((digitalRead(keyButton) == false) && (cherry1 == false) && (millis() > bouncetimerB1))
  {
    cherry1 = true;
    // Serial.println("cherry on");
    bouncetimerA1 = millis() + 50;
  }

  if ((digitalRead(keyButton) == true) && (cherry1 == true) && (millis() > bouncetimerA1))
  {
    cherry1 = false;
    // Serial.println("cherry off");
    bouncetimerB1 = millis() + 50;
  }



  //////////////////////////////////////////////////////////
  // FLUTE PLAY
  /////////////////////////////////////////////////////////

  //calculate flute tube length for fundamental and fifth
  tubevalue1 = scalefilter[hyster_closest_scale_number];  //root
  if (tubevalue1 > 46) tubevalue1 = 46;                   //limits of flute model
  if (tubevalue1 < 20) tubevalue1 = 20;                   //limits of flute model

  tubevalue2 = scalefilter[hyster_closest_scale_number + 4];  // fifth
  if (tubevalue2 > 46) tubevalue2 = 46;                       //limits of flute model
  if (tubevalue2 < 20) tubevalue2 = 20;                       //limits of flute model


  // pushbutton logic
  //first press
  if ((cherry1 == true) && (button1toggle == false))  //button on
  {
    button1toggle = true;
    lightstall = false;

    //Audio out (jack and USB)
    dc1.amplitude(1, 100);   //pressure control--Faust model
    dc2.amplitude(1, 3000);  //vibrato gain

    AudioNoInterrupts();
    flute1.setParamValue("tubeLength", tubelength[tubevalue1]);
    flute2.setParamValue("tubeLength", tubelength[tubevalue2]);
    AudioInterrupts();

    //MIDI out
    if (wokenstall == true)
    {
      usbMIDI.sendNoteOn(midiconvert[scalefilter[hyster_closest_scale_number]], MIDIvolume, 2);

      // Serial.print(midiconvert[scalefilter[hyster_closest_scale_number]]);
      // Serial.print("   ");
      // Serial.print(scalefilter[hyster_closest_scale_number]);
      // Serial.print("   ");
      // Serial.println(hyster_closest_scale_number);
      // for (int x = 0; x < 30; x++)
      // {
      //   Serial.print(x);
      //   Serial.print(" :");
      //   Serial.println(scalefilter[x]);
      // }



      MIDI.sendNoteOn(midiconvert[scalefilter[hyster_closest_scale_number]], MIDIvolume, 2);
    }
    //    if (midiconvert[scalefilter[hyster_closest_scale_number]] != lastMIDI)
    //      usbMIDI.sendNoteOff(lastMIDI, 0, 2);
    lastMIDI = midiconvert[scalefilter[hyster_closest_scale_number]];
    hysterpreviousplayednotenumber1 = hyster_closest_scale_number;
  }





  //aftertouch pitch change
  if ((cherry1 == true) && (hyster_closest_scale_number != hysterpreviousplayednotenumber1))
  {
    if (note_mode == 0)  //notes turn off before move to new frequency
    {
      //repeat_count++;  //only articulate a few notes
      if (repeat_count < 6) dc1.amplitude(0, 0);  //pressure control
      dc1.amplitude(1, 20);                       //pressure control##
      repeat_time = millis();
    }
    dc2.amplitude(0, 0);     //vibrato gain  //reset vibrato if notes are changing
    dc2.amplitude(1, 3000);  //vibrato gain


    AudioNoInterrupts();
    flute1.setParamValue("tubeLength", tubelength[tubevalue1]);
    flute2.setParamValue("tubeLength", tubelength[tubevalue2]);
    AudioInterrupts();

    hysterpreviousplayednotenumber1 = hyster_closest_scale_number;
    if (wokenstall == true)
    {
      usbMIDI.sendNoteOn(midiconvert[scalefilter[hyster_closest_scale_number]], MIDIvolume, 2);
      MIDI.sendNoteOn(midiconvert[scalefilter[hyster_closest_scale_number]], MIDIvolume, 2);
    }
    usbMIDI.sendNoteOff(lastMIDI, 0, 2);
    MIDI.sendNoteOff(lastMIDI, 0, 2);
    lastMIDI = midiconvert[scalefilter[hyster_closest_scale_number]];
  }

  if (millis() - repeat_time > 500) repeat_count = 0;  //reset articulation after a while

  //key released
  if ((cherry1 == false) && (button1toggle == true))
  {
    dc1.amplitude(0, 10);   //pressure control
    dc2.amplitude(0, 100);  //vibrato gain
    button1toggle = false;
    usbMIDI.sendNoteOff(lastMIDI, 0, 2);
    MIDI.sendNoteOff(lastMIDI, 0, 2);
    lastMIDI = 0;
    repeat_count = 0;
  }

  //*******************************************************
  //  Joystick processing

  //****************************************************


  // if (joyprocessingtime + 100 < millis())
  // {
  //   joyprocessingtime = millis();
  //convert joystickvalues to flute control values

  if (rawjoystickvalue1 > 128)  //forward/backward
  {
    note_mode = 1;
    flutepedal_1 = mapfloat(rawjoystickvalue1, 128, 255, .6, 1);
    colorsaturation = mapfloat(rawjoystickvalue1, 128, 255, .01, .1);
  }

  if (rawjoystickvalue1 <= 128)
  {
    note_mode = 0;
    flutepedal_1 = dc1.read() * mapfloat(rawjoystickvalue1, 0, 127, 1, .7);
    colorsaturation = mapfloat(rawjoystickvalue1, 0, 127, .1, .01);
  }

  if ((rawjoystickvalue1 > 120) && (rawjoystickvalue1 < 136)) dc2.amplitude(0, 100);  //reset vibrato if not sound

  if (rawjoystickvalue2 > 128)  //left/right
  {
    expressionpedal2 = map(rawjoystickvalue2, 128, 255, 0, 127);
    expressionpedal3 = 0;
    flutepedal_2 = mapfloat(rawjoystickvalue2, 128, 255, .46, 1);
    flutepedal_3 = 0;
    flutepedal_0 = mapfloat(rawjoystickvalue2, 128, 255, .6, 1);
    //tempgreen = expressionpedal2;
  }
  if (rawjoystickvalue2 <= 128)
  {
    expressionpedal3 = map(rawjoystickvalue2, 0, 128, 127, 0);
    expressionpedal2 = 0;
    flutepedal_3 = mapfloat(rawjoystickvalue2, 0, 128, .5, 0);
    flutepedal_2 = .46;
    flutepedal_0 = dc1.read() * mapfloat(rawjoystickvalue2, 0, 127, 1, .7);
  }

  if (flutepedal_0 > flutepedal_1) flutepedal_1 = flutepedal_0;

  AudioNoInterrupts();
  flute1.setParamValue("pressure", flutepedal_1);
  flute2.setParamValue("pressure", flutepedal_1);
  flute1.setParamValue("mouthPosition", flutepedal_2);
  flute1.setParamValue("vibratoGain", dc2.read() * 3);
  flute1.setParamValue("outGain", .5);
  flute2.setParamValue("mouthPosition", flutepedal_2);
  flute2.setParamValue("vibratoGain", dc2.read());
  flute2.setParamValue("outGain", flutepedal_3 / 2);
  AudioInterrupts();


  //convert joystickvalues to midi control values

  expressionpedal1 = map(rawjoystickvalue1, 0, 255, 0, 127);

  if (abs(expressionpedal1 - lastexpression1) > 2)
  {
    lastexpression1 = expressionpedal1;
    usbMIDI.sendControlChange(11, expressionpedal1, 1);  //expression
    MIDI.sendControlChange(11, expressionpedal1, 1);     //expression
  }

  if (abs(expressionpedal2 - lastexpression2) > 2)
  {
    //Serial.println(expressionpedal);
    lastexpression2 = expressionpedal2;
    usbMIDI.sendControlChange(4, expressionpedal2, 1);  //
    MIDI.sendControlChange(4, expressionpedal2, 1);     //expression
  }

  if (abs(expressionpedal3 - lastexpression3) > 2)
  {
    //Serial.println(expressionpedal);
    lastexpression3 = expressionpedal3;
    usbMIDI.sendControlChange(1, expressionpedal3, 1);  //expression
    MIDI.sendControlChange(1, expressionpedal3, 1);     //expression
  }
  // }

  //*****************************************************************************************
  //end of flute logic
  //*************************************************************************************

  if ((woken == false) && (uncolor + 1000) < millis())  //turn off LEDs after 1 second
  {
    analogWrite(bluePin, 1024);  //off
    analogWrite(greenPin, 1024);
    analogWrite(redPin, 1024);

    for (int x = 0; x < 16; x++)
    {
      leds.setPixel(x, 0);
      leds.show();
      delay(1);
    }
  }


  // change all the LEDs in 1.5 seconds

  if ((lighttime < micros()) && (woken == true))
  {
    lighttime = micros() + 1500000 / leds.numPixels();
    ledcounter++;
    if (ledcounter > leds.numPixels() - 1)
    {
      ledcounter = 0;
      colorcounter++;
      if (colorcounter > 6) colorcounter = 0;
    }

    int pixelnumber = random(0, 16);
    colorcounter = random(0, 7);

    if (lightstall == true)
    {
      switch (colorcounter)
      {
        case 0:
          leds.setPixel(pixelnumber, RED);
          leds.show();
          break;
        case 1:
          leds.setPixel(pixelnumber, GREEN);
          leds.show();
          break;
        case 2:
          leds.setPixel(pixelnumber, BLUE);
          leds.show();
          break;
        case 3:
          leds.setPixel(pixelnumber, YELLOW);
          leds.show();
          break;
        case 4:
          leds.setPixel(pixelnumber, PINK);
          leds.show();
          break;
        case 5:
          leds.setPixel(pixelnumber, ORANGE);
          leds.show();
          break;
        case 6:
          leds.setPixel(pixelnumber, WHITE);
          leds.show();
          break;
        default:
          // if nothing else matches, do the default
          // default is optional
          break;
      }
    }
    else
    {
      leds.setPixel(ledcounter, nowcolor);
      leds.show();
    }
  }



}  //end of main *********************************************************************************************************


////////////////////////////////////////////////////
//     FUNCTIONS
///////////////////////////////////////////////////




//////////////////////////////////////////////////////////
// GRABDATA FUNCTION  ISR to buffer microphone samples for analysis
//  executes every 20 us
/////////////////////////////////////////////////////////
void grabdata()
{

  ///****************monitor output*****************************
  //Sine wave output to monitor output
  unsigned long temptime = micros();  //figure out sine table lookup
  int tableindex = int((temptime - ISRlasttime) / sineincrement);
  if (tableindex >= 100)
  {
    tableindex = 0;
    ISRlasttime = temptime;  //rising edge is always
  }
  monitorval = int(sinetable[tableindex] * monitorsquelch);
  if ((woken == true))  // && (sineincrement > 2.54))
  {
    analogWrite(monitorPin1, monitorval);
    analogWrite(monitorPin2, monitorval);
  }


  //****************monitor output*****************************

  rawmicbuffer[h] = analogRead(micInputPin);  // * ultimatespeakergain - gainoffset; //read mouth microphone

  filtercoeff = 2;  //int(ultimatefilter); //pseudo low pass filter

  int startave = 0;
  if (h - filtercoeff < 0) startave = h - filtercoeff + BUFFSIZE;
  else
    startave = h - filtercoeff;
  float ave = 0;
  for (int x = 0; x < filtercoeff; x++)
  {
    ave = ave + rawmicbuffer[startave];
    startave++;
    if (startave >= BUFFSIZE) startave = 0;
  }
  ave = ave / filtercoeff;
  filteredmicbuffer[h] = int(ave);  //filtered value

  //phase shift per frequency
  int temp0 = h;
  temp0 = temp0 - int(polyultimatephase / 1.7);  //is 2 fro some devices


  if (temp0 < 0) temp0 = temp0 + BUFFSIZE;



  driveval = (1204 - int(filteredmicbuffer[temp0] * 4 * rampup * ultimatespeakergain));


  h++;
  if (h >= BUFFSIZE) h = 0;
  if (woken == false) driveval = 0;

  analogWrite(mouthSpkrOutput, driveval);  //output to mouth  speaker
}

//////////////////////////////////////////////////////////
// COLORME FUNCTION  sets led color
/////////////////////////////////////////////////////////
void Colorme(int color)
{
  uncolor = millis();
  //analogWrite(bluePin, 1024);
  switch (color)
  {

    case 0:
      analogWrite(bluePin, 256);  //blue
      analogWrite(greenPin, 1024);
      analogWrite(redPin, 1024);
      break;
    case 1:
      analogWrite(bluePin, 1024);  //red
      analogWrite(greenPin, 1024);
      analogWrite(redPin, 256);
      break;
    case 2:
      analogWrite(bluePin, 1024);  //green
      analogWrite(greenPin, 256);
      analogWrite(redPin, 1024);
      break;
    case 3:
      analogWrite(bluePin, 256);  //Aqua
      analogWrite(greenPin, 256);
      analogWrite(redPin, 1024);
      break;
    case 4:
      analogWrite(bluePin, 1024);  //Yellow
      analogWrite(greenPin, 256);
      analogWrite(redPin, 256);
      break;
    case 5:
      analogWrite(bluePin, 246);  //pink
      analogWrite(greenPin, 1024);
      analogWrite(redPin, 64);
      break;
    case 6:
      analogWrite(bluePin, 64);  //violet
      analogWrite(greenPin, 1024);
      analogWrite(redPin, 800);
      break;
    case 7:
      analogWrite(bluePin, 1024);  //orange
      analogWrite(greenPin, 802);
      analogWrite(redPin, 66);
      break;
    case 8:
      analogWrite(bluePin, 256);  //white
      analogWrite(greenPin, 256);
      analogWrite(redPin, 512);
      break;
    case 9:
      analogWrite(bluePin, 1024);  //off
      analogWrite(greenPin, 1024);
      analogWrite(redPin, 1024);
      break;
    default:
      // if nothing else matches, do the default
      // default is optional
      break;
  }
}

//////////////////////////////////////////////////////////
// MAPFLOAT FUNCTION  map float values to ranges
/////////////////////////////////////////////////////////


float mapfloat(float x, float in_min, float in_max, float out_min, float out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float bound1(float val)
{
  if (val > 1) return 1;
  if (val < 0) return 0;
  return val;
}

//////////////////////////////////////////////////////////
// COLOR WIPE  led ring function--not implimented
/////////////////////////////////////////////////////////

//void colorWipe(int color, int wait)
//{
//  if (lighttime < micros())
//{
//  for (int i = 0; i < leds.numPixels(); i++)
//  {
////    leds.setPixel(i, color);
////    leds.show();
//    // delayMicroseconds(wait);
//    while
//    lighttime = micros() + 1000;
//  }
//}



